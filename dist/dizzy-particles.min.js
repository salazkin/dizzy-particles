const t=t=>t*Math.PI/180,e=(t,e,s)=>t+(e-t)*s,s=(t,s,a,i=360)=>{let r;const o=s-t,n=.5*i;return o<-n?(r=e(t,s+=i,a),r>=i&&(r-=i)):o>n?(r=e(t,s-=i,a),r<0&&(r+=i)):r=e(t,s,a),r},a=(t,s,a,i)=>{const r=e(t.x,s.x,a),o=e(t.y,s.y,a);if(!i)return{x:r,y:o};i.x=r,i.y=o},i=(t,e,s,a,i,r)=>{const o=i*i,n=i*i*i,h=Math.pow(1-i,3)*t.x+3*Math.pow(1-i,2)*i*e.x+3*(1-i)*o*s.x+n*a.x,l=Math.pow(1-i,3)*t.y+3*Math.pow(1-i,2)*i*e.y+3*(1-i)*o*s.y+n*a.y;if(!r)return{x:h,y:l};r.x=h,r.y=l},r=(t,e,s)=>{let a,i,r;if(0==e)a=i=r=s;else{let o=s<.5?s*(1+e):s+e-s*e,n=2*s-o;const h=(t,e,s)=>(t<0&&(t+=1),t>1&&(t-=1),t<1/6?e+6*(s-e)*t:t<.5?s:t<2/3?e+(s-e)*(2/3-t)*6:e);a=Math.round(255*h(t+1/3,n,o)),i=Math.round(255*h(t,n,o)),r=Math.round(255*h(t-1/3,n,o))}return((t,e,s)=>t<<16|e<<8|s)(a,i,r)};class o{constructor(){this.x=0,this.y=0}}class n{constructor(t,e,s,a){this.totalParticles=t,this.loop=e,this.config=s,this.cb=a,this.particles=[],this.time=0,this.delay=0,this.posStart={x:0,y:0},this.posEnd={x:0,y:0},this.curveLen=20,this.curveSeg=1/(this.curveLen-1),this.correctedTintArr=null,this.createParticles(t)}createParticles(t){for(let e=0;e<t;e++){const t=this.createParticle();t.alpha=0;const e={result:t,updated:!1,delay:this.getDelay(),duration:this.getDuration()};this.particles.push(e)}}createParticle(){return{x:0,y:0,alpha:1,scaleX:1,scaleY:1,rotation:0,tint:16777215}}update(t){const e=this.time;let s=0;this.particles.forEach((t=>{if(0===t.duration)return void s++;const a=(e-t.delay)/t.duration;a>=0&&a<=1?(t.result.alpha=1,t.updated||(t.updated=!0,this.updateParticleData(t)),this.updateResult(t,a)):(t.updated=!1,t.result.alpha=0),e>=t.delay+t.duration&&(this.loop?(t.duration=this.getDuration(),t.delay=this.getDelay()):(s++,t.duration=0,t.result.alpha=0))})),this.delay=0,this.time+=t,s>=this.particles.length&&this.onComplete()}reset(){this.time=0,this.delay=0,this.particles.forEach((t=>{t.updated=!1,t.delay=this.getDelay(),t.duration=this.getDuration(),t.result&&(t.result.alpha=0,t.result.x=0,t.result.y=0)}))}onComplete(){this.cb&&this.cb()}set posStartX(t){this.posStart.x=t}set posStartY(t){this.posStart.y=t}set posEndX(t){this.posEnd.x=t}set posEndY(t){this.posEnd.y=t}setPosStart(t,e){this.posStart.x=t,this.posStart.y=e}setPosEnd(t,e){this.posEnd.x=t,this.posEnd.y=e}setData(t){this.correctedTintArr=null,this.config=t}getDuration(){return this.getValue("duration")}getDelay(){return this.delay+=this.getValue("delay"),this.time+this.delay}updateParticleData(e){const s=this.posStart.x+this.getValue("posStartOffsetX"),a=this.posStart.y+this.getValue("posStartOffsetY"),i=this.posEnd.x+this.getValue("posEndOffsetX"),r=this.posEnd.y+this.getValue("posEndOffsetY");e.posStart={x:s,y:a},e.posEnd={x:i,y:r},e.cp1=null,e.cp2=null;const o=this.getValue("posControlPoint1Mag"),n=this.getValue("posControlPoint2Mag");if(0!==o||0!==n){const h=i-s,l=r-a,c=Math.atan2(h,l),u=c+t(this.getValue("posControlPoint1Angle")),p=-(Math.PI-c)+t(this.getValue("posControlPoint2Angle")),d=Math.sqrt(h*h+l*l);e.cp1={x:s+Math.sin(u)*d*o,y:a+Math.cos(u)*d*o},e.cp2={x:i+Math.sin(p)*d*n,y:r+Math.cos(p)*d*n},e.curve?e.curve.length=0:e.curve=[]}else e.curve=void 0;e.alphaFrom=this.getValue("alphaFrom"),e.alphaTo=this.getValue("alphaTo"),e.alphaYoYo=this.getValue("alphaYoYo"),this.config.tint&&(this.config.tintInterpolate&&Array.isArray(this.config.tint)&&this.config.tint.length>1?(this.correctedTintArr||(this.correctedTintArr=h(this.config.tint,10)),e.tint=this.correctedTintArr):e.tint=parseInt(this.getValue("tint"))),e.scaleFrom=this.getValue("scaleFrom"),e.scaleTo=this.getValue("scaleTo"),e.scaleYoYo=this.getValue("scaleYoYo"),e.rotationSpeed=t(this.getValue("rotationSpeed"))}getValue(t){if(Array.isArray(this.config[t])){const e=this.config[t],s=e.length>1?Math.floor(Math.random()*e.length):0;if(Array.isArray(e[s])){const t=e[s][0],a=e[s][1];return Math.random()*(a-t)+t}return e[s]}return this.config[t]||0}updateResult(t,s){const r=s*(1-s)*2,n=t.result;if(n.alpha=t.alphaFrom+(t.alphaTo-t.alphaFrom)*(t.alphaYoYo?r:s),n.scaleX=n.scaleY=e(t.scaleFrom,t.scaleTo,t.scaleYoYo?r:s),t.curve){const e=Math.floor(s/this.curveSeg),r=e+1;void 0===t.curve[e]&&(t.curve[e]=0===e?t.posStart:new o),void 0===t.curve[r]&&(t.curve[r]=r===this.curveLen-1?t.posEnd:new o),0!==e&&i(t.posStart,t.cp1,t.cp2,t.posEnd,e*this.curveSeg,t.curve[e]),r!==this.curveLen-1&&i(t.posStart,t.cp1,t.cp2,t.posEnd,r*this.curveSeg,t.curve[r]),a(t.curve[e],t.curve[r],s%this.curveSeg/this.curveSeg,n)}else a(t.posStart,t.posEnd,s,n);if(0!==t.rotationSpeed?n.rotation+=t.rotationSpeed:n.rotation=0,t.tint)if(Array.isArray(t.tint)){const e=1/(t.tint.length-1);n.tint=t.tint[Math.floor(s/e)]}else n.tint=t.tint}kill(){this.particles.length=0,this.cb=null}}const h=(t,e)=>{const a=t.map((t=>(t=>{const e=(t>>16)/255,s=(t>>8&255)/255,a=(255&t)/255,i=Math.max(e,s,a),r=Math.min(e,s,a);let o=(i+r)/2,n=0,h=0;if(i!==r){const t=i-r;n=o<.5?t/(i+r):t/(2-i-r),h=e==i?(s-a)/t+(s<a?6:0):s==i?2+(a-e)/t:4+(e-s)/t}return h/=6,[h,n,o]})(parseInt(t)))),i=[],o=1/e,n=1/(a.length-1);for(let t=0;t<e+1;t++){const e=Math.min(o*t,1),h=Math.min(Math.floor(e/n),a.length-2),l=a[h],c=a[h+1];i.push(r(...l.map(((t,a)=>s(t,c[a],e)))))}return i};export{n as Particles};
//# sourceMappingURL=dizzy-particles.min.js.map
