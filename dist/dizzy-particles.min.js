class t{constructor(){this.x=0,this.y=0}}class e{constructor(){this.x=0,this.y=0,this.alpha=1,this.scaleX=0,this.scaleY=0,this.rotation=0,this.tint="0xff0000"}}class i{constructor(t,e,i,a){this.totalParticles=t,this.loop=e,this.config=i,this.cb=a,this.particles=[],this.particleDataArr=[],this.time=0,this.delay=0,this.posStart={x:0,y:0},this.posEnd={x:0,y:0},this.curveLen=20,this.curveSeg=1/(this.curveLen-1),this.correctedTintArr=null,this.createParticles(t)}createParticles(t){for(let i=0;i<t;i++){const t=new e;t.alpha=0,this.particles[i]=t,this.particleDataArr.push({particle:this.particles[i],configUpdated:!1,delay:this.getDelay(),duration:this.getDuration(),config:{}})}}update(t){const e=this.time;let i=0;this.particleDataArr.forEach((t=>{if(0===t.duration)return void i++;const a=(e-t.delay)/t.duration;a>=0&&a<=1?(t.particle.alpha=1,t.configUpdated||(t.configUpdated=!0,this.updateConfig(t.config)),this.onUpdateParticle(t.particle,t.config,a)):(t.configUpdated=!1,t.particle.alpha=0),e>=t.delay+t.duration&&(this.loop?(t.duration=this.getDuration(),t.delay=this.getDelay()):(i++,t.duration=0,t.particle.alpha=0))})),this.delay=0,this.time+=t,i>=this.particleDataArr.length&&this.onComplete()}reset(){this.time=0,this.delay=0,this.particleDataArr.forEach((t=>{t.configUpdated=!1,t.delay=this.getDelay(),t.duration=this.getDuration(),t.particle&&(t.particle.alpha=0,t.particle.x=0,t.particle.y=0)}))}onComplete(){this.cb&&this.cb()}set posStartX(t){this.posStart.x=t}set posStartY(t){this.posStart.y=t}set posEndX(t){this.posEnd.x=t}set posEndY(t){this.posEnd.y=t}setPosStart(t,e){this.posStart.x=t,this.posStart.y=e}setPosEnd(t,e){this.posEnd.x=t,this.posEnd.y=e}setData(t){this.correctedTintArr=null,this.config=t}getDuration(){return this.getValue("duration")}getDelay(){return this.delay+=this.getValue("delay"),this.time+this.delay}updateConfig(t){const e=this.posStart.x+this.getValue("posStartOffsetX"),i=this.posStart.y+this.getValue("posStartOffsetY"),s=this.posEnd.x+this.getValue("posEndOffsetX"),r=this.posEnd.y+this.getValue("posEndOffsetY");t.posStart={x:e,y:i},t.posEnd={x:s,y:r},t.cp1=null,t.cp2=null;const o=this.getValue("posControlPoint1Mag"),n=this.getValue("posControlPoint2Mag");if(0!==o||0!==n){let a=s-e,h=r-i,c=Math.atan2(a,h),p=c+l(this.getValue("posControlPoint1Angle")),u=-(Math.PI-c)+l(this.getValue("posControlPoint2Angle")),g=Math.sqrt(a*a+h*h);t.cp1={x:e+Math.sin(p)*g*o,y:i+Math.cos(p)*g*o},t.cp2={x:s+Math.sin(u)*g*n,y:r+Math.cos(u)*g*n},t.curve?t.curve.length=0:t.curve=[]}t.alphaFrom=this.getValue("alphaFrom"),t.alphaTo=this.getValue("alphaTo"),t.alphaYoYo=this.getValue("alphaYoYo"),this.config.tint&&(this.config.tintInterpolate&&Array.isArray(this.config.tint)&&this.config.tint.length>1?(this.correctedTintArr||(this.correctedTintArr=a(this.config.tint,5)),t.tint=this.correctedTintArr):t.tint=this.getValue("tint")),t.scaleFrom=this.getValue("scaleFrom"),t.scaleTo=this.getValue("scaleTo"),t.scaleYoYo=this.getValue("scaleYoYo"),t.rotationSpeed=l(this.getValue("rotationSpeed"))}getValue(t){if(Array.isArray(this.config[t])){const e=this.config[t],i=e.length>1?Math.floor(Math.random()*e.length):0;if(Array.isArray(e[i])){const t=e[i][0],a=e[i][1];return Math.random()*(a-t)+t}return e[i]}return this.config[t]||0}onUpdateParticle(e,i,a){const r=a*(1-a)*2;if(e.alpha=i.alphaFrom+(i.alphaTo-i.alphaFrom)*(i.alphaYoYo?r:a),e.scaleX=e.scaleY=s(i.scaleYoYo?r:a,i.scaleFrom,i.scaleTo),i.curve){const s=Math.floor(a/this.curveSeg),r=s+1;void 0===i.curve[s]&&(i.curve[s]=0===s?i.posStart:new t),void 0===i.curve[r]&&(i.curve[r]=r===this.curveLen-1?i.posEnd:new t),0!==s&&p(i.curve[s],s*this.curveSeg,i.posStart,i.posEnd,i.cp1,i.cp2),r!==this.curveLen-1&&p(i.curve[r],r*this.curveSeg,i.posStart,i.posEnd,i.cp1,i.cp2),c(e,a%this.curveSeg/this.curveSeg,i.curve[s],i.curve[r])}else c(e,a,i.posStart,i.posEnd);if(0!==i.rotationSpeed?e.rotation+=i.rotationSpeed:e.rotation=0,i.tint)if(Array.isArray(i.tint)){const t=1/(i.tint.length-1);e.tint=i.tint[Math.floor(a/t)]}else e.tint=i.tint}kill(){this.particleDataArr.length=0,this.cb=null}}const a=(t,e)=>{const i=t.map((t=>r(t))),a=[],n=1/e;for(let t=0;t<e+1;t++){const e=Math.min(n*t,1),r=1/(i.length-1),h=Math.min(Math.floor(e/r),i.length-2),l=i[h],c=i[h+1];a.push(o(l.map(((t,i)=>s(e,t,c[i],0===i)))))}return a},s=(t,e,i,a)=>{if(!a)return e+(i-e)*t;const s=Math.min(e,i),r=Math.max(e,i),o=r-s,n=1-r+s;return o<n?s+o*t:(r+n*t)%1},r=t=>{const e=parseInt(t.substring(t.length-6,t.length-4),16)/255,i=parseInt(t.substring(t.length-4,t.length-2),16)/255,a=parseInt(t.substring(t.length-2,t.length),16)/255,s=Math.max(e,i,a),r=Math.min(e,i,a);let o=(s+r)/2,n=0,h=0;if(s!==r){const t=s-r;n=o<.5?t/(s+r):t/(2-s-r),h=e==s?(i-a)/t+(i<a?6:0):i==s?2+(a-e)/t:4+(e-i)/t}return h/=6,[h,n,o]},o=t=>{let e,i,a,s=t[0],r=t[1],o=t[2];if(0==r)e=i=a=o;else{let t=o<.5?o*(1+r):o+r-o*r,h=2*o-t;e=Math.round(255*n(s+1/3,h,t)),i=Math.round(255*n(s,h,t)),a=Math.round(255*n(s-1/3,h,t))}return"0x"+h(e)+h(i)+h(a)},n=(t,e,i)=>(t<0&&(t+=1),t>1&&(t-=1),t<1/6?e+6*(i-e)*t:t<.5?i:t<2/3?e+(i-e)*(2/3-t)*6:e),h=t=>("0"+t.toString(16)).slice(-2),l=t=>t*Math.PI/180,c=(t,e,i,a)=>{t.x=i.x+(a.x-i.x)*e,t.y=i.y+(a.y-i.y)*e},p=(t,e,i,a,s,r)=>{const o=e*e,n=e*e*e;t.x=Math.pow(1-e,3)*i.x+3*Math.pow(1-e,2)*e*s.x+3*(1-e)*o*r.x+n*a.x,t.y=Math.pow(1-e,3)*i.y+3*Math.pow(1-e,2)*e*s.y+3*(1-e)*o*r.y+n*a.y};export{i as Particles};
//# sourceMappingURL=dizzy-particles.min.js.map
