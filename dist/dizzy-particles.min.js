const t=t=>t*Math.PI/180,e=(t,e,s,a=!1)=>{if(a){const a=Math.min(e,s),i=Math.max(e,s),r=i-a,o=1-i+a;return r<o?a+r*t:(i+o*t)%1}return e+(s-e)*t},s=(t,s,a,i)=>{const r=e(t,s.x,a.x),o=e(t,s.y,a.y);if(void 0===i)return{x:r,y:o};i.x=r,i.y=o},a=(t,e,s,a,i,r)=>{const o=t*t,n=t*t*t,h=Math.pow(1-t,3)*e.x+3*Math.pow(1-t,2)*t*a.x+3*(1-t)*o*i.x+n*s.x,l=Math.pow(1-t,3)*e.y+3*Math.pow(1-t,2)*t*a.y+3*(1-t)*o*i.y+n*s.y;if(void 0===r)return{x:h,y:l};r.x=h,r.y=l},i=t=>{let e,s,a,i=t[0],r=t[1],o=t[2];if(0==r)e=s=a=o;else{let t=o<.5?o*(1+r):o+r-o*r,n=2*o-t;const h=(t,e,s)=>(t<0&&(t+=1),t>1&&(t-=1),t<1/6?e+6*(s-e)*t:t<.5?s:t<2/3?e+(s-e)*(2/3-t)*6:e);e=Math.round(255*h(i+1/3,n,t)),s=Math.round(255*h(i,n,t)),a=Math.round(255*h(i-1/3,n,t))}const n=t=>("0"+t.toString(16)).slice(-2);return"0x"+n(e)+n(s)+n(a)};class r{constructor(){this.x=0,this.y=0}}class o{constructor(t,e,s,a){this.totalParticles=t,this.loop=e,this.config=s,this.cb=a,this.particles=[],this.time=0,this.delay=0,this.posStart={x:0,y:0},this.posEnd={x:0,y:0},this.curveLen=20,this.curveSeg=1/(this.curveLen-1),this.correctedTintArr=null,this.createParticles(t)}createParticles(t){for(let e=0;e<t;e++){const t=this.createParticle();t.alpha=0;const e={result:t,updated:!1,delay:this.getDelay(),duration:this.getDuration()};this.particles.push(e)}}createParticle(){return{x:0,y:0,alpha:1,scaleX:1,scaleY:1,rotation:0,tint:"0xffffff"}}update(t){const e=this.time;let s=0;this.particles.forEach((t=>{if(0===t.duration)return void s++;const a=(e-t.delay)/t.duration;a>=0&&a<=1?(t.result.alpha=1,t.updated||(t.updated=!0,this.updateParticleData(t)),this.updateResult(t,a)):(t.updated=!1,t.result.alpha=0),e>=t.delay+t.duration&&(this.loop?(t.duration=this.getDuration(),t.delay=this.getDelay()):(s++,t.duration=0,t.result.alpha=0))})),this.delay=0,this.time+=t,s>=this.particles.length&&this.onComplete()}reset(){this.time=0,this.delay=0,this.particles.forEach((t=>{t.updated=!1,t.delay=this.getDelay(),t.duration=this.getDuration(),t.result&&(t.result.alpha=0,t.result.x=0,t.result.y=0)}))}onComplete(){this.cb&&this.cb()}set posStartX(t){this.posStart.x=t}set posStartY(t){this.posStart.y=t}set posEndX(t){this.posEnd.x=t}set posEndY(t){this.posEnd.y=t}setPosStart(t,e){this.posStart.x=t,this.posStart.y=e}setPosEnd(t,e){this.posEnd.x=t,this.posEnd.y=e}setData(t){this.correctedTintArr=null,this.config=t}getDuration(){return this.getValue("duration")}getDelay(){return this.delay+=this.getValue("delay"),this.time+this.delay}updateParticleData(e){const s=this.posStart.x+this.getValue("posStartOffsetX"),a=this.posStart.y+this.getValue("posStartOffsetY"),i=this.posEnd.x+this.getValue("posEndOffsetX"),r=this.posEnd.y+this.getValue("posEndOffsetY");e.posStart={x:s,y:a},e.posEnd={x:i,y:r},e.cp1=null,e.cp2=null;const o=this.getValue("posControlPoint1Mag"),h=this.getValue("posControlPoint2Mag");if(0!==o||0!==h){let n=i-s,l=r-a,c=Math.atan2(n,l),u=c+t(this.getValue("posControlPoint1Angle")),p=-(Math.PI-c)+t(this.getValue("posControlPoint2Angle")),d=Math.sqrt(n*n+l*l);e.cp1={x:s+Math.sin(u)*d*o,y:a+Math.cos(u)*d*o},e.cp2={x:i+Math.sin(p)*d*h,y:r+Math.cos(p)*d*h},e.curve?e.curve.length=0:e.curve=[]}else e.curve=void 0;e.alphaFrom=this.getValue("alphaFrom"),e.alphaTo=this.getValue("alphaTo"),e.alphaYoYo=this.getValue("alphaYoYo"),this.config.tint&&(this.config.tintInterpolate&&Array.isArray(this.config.tint)&&this.config.tint.length>1?(this.correctedTintArr||(this.correctedTintArr=n(this.config.tint,5)),e.tint=this.correctedTintArr):e.tint=this.getValue("tint")),e.scaleFrom=this.getValue("scaleFrom"),e.scaleTo=this.getValue("scaleTo"),e.scaleYoYo=this.getValue("scaleYoYo"),e.rotationSpeed=t(this.getValue("rotationSpeed"))}getValue(t){if(Array.isArray(this.config[t])){const e=this.config[t],s=e.length>1?Math.floor(Math.random()*e.length):0;if(Array.isArray(e[s])){const t=e[s][0],a=e[s][1];return Math.random()*(a-t)+t}return e[s]}return this.config[t]||0}updateResult(t,i){const o=i*(1-i)*2,n=t.result;if(n.alpha=t.alphaFrom+(t.alphaTo-t.alphaFrom)*(t.alphaYoYo?o:i),n.scaleX=n.scaleY=e(t.scaleYoYo?o:i,t.scaleFrom,t.scaleTo),t.curve){const e=Math.floor(i/this.curveSeg),o=e+1;void 0===t.curve[e]&&(t.curve[e]=0===e?t.posStart:new r),void 0===t.curve[o]&&(t.curve[o]=o===this.curveLen-1?t.posEnd:new r),0!==e&&a(e*this.curveSeg,t.posStart,t.posEnd,t.cp1,t.cp2,t.curve[e]),o!==this.curveLen-1&&a(o*this.curveSeg,t.posStart,t.posEnd,t.cp1,t.cp2,t.curve[o]),s(i%this.curveSeg/this.curveSeg,t.curve[e],t.curve[o],n)}else s(i,t.posStart,t.posEnd,n);if(0!==t.rotationSpeed?n.rotation+=t.rotationSpeed:n.rotation=0,t.tint)if(Array.isArray(t.tint)){const e=1/(t.tint.length-1);n.tint=t.tint[Math.floor(i/e)]}else n.tint=t.tint}kill(){this.particles.length=0,this.cb=null}}const n=(t,s)=>{const a=t.map((t=>(t=>{const e=parseInt(t.substring(t.length-6,t.length-4),16)/255,s=parseInt(t.substring(t.length-4,t.length-2),16)/255,a=parseInt(t.substring(t.length-2,t.length),16)/255,i=Math.max(e,s,a),r=Math.min(e,s,a);let o=(i+r)/2,n=0,h=0;if(i!==r){const t=i-r;n=o<.5?t/(i+r):t/(2-i-r),h=e==i?(s-a)/t+(s<a?6:0):s==i?2+(a-e)/t:4+(e-s)/t}return h/=6,[h,n,o]})(t))),r=[],o=1/s;for(let t=0;t<s+1;t++){const s=Math.min(o*t,1),n=1/(a.length-1),h=Math.min(Math.floor(s/n),a.length-2),l=a[h],c=a[h+1];r.push(i(l.map(((t,a)=>e(s,t,c[a],0===a)))))}return r};export{o as Particles};
//# sourceMappingURL=dizzy-particles.min.js.map
