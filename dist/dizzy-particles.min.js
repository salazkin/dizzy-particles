import{degreeToRadians as t,interpolate as e,cubicBezierCurveInterpolate as s,lineInterpolate as a,hexToHsl as i,hslToHex as r,angleInterpolate as o}from"dizzy-utils";class h{constructor(){this.x=0,this.y=0}}class l{constructor(t,e,s,a){this.totalParticles=t,this.loop=e,this.config=s,this.cb=a,this.particles=[],this.time=0,this.delay=0,this.posStart={x:0,y:0},this.posEnd={x:0,y:0},this.curveLen=20,this.curveSeg=1/(this.curveLen-1),this.correctedTintArr=null,this.createParticles(t)}createParticles(t){for(let e=0;e<t;e++){const t=this.createParticle();t.alpha=0;const e={result:t,updated:!1,delay:this.getDelay(),duration:this.getDuration()};this.particles.push(e)}}createParticle(){return{x:0,y:0,alpha:1,scaleX:1,scaleY:1,rotation:0,tint:16777215}}update(t){const e=this.time;let s=0;this.particles.forEach((t=>{if(0===t.duration)return void s++;const a=(e-t.delay)/t.duration;a>=0&&a<=1?(t.result.alpha=1,t.updated||(t.updated=!0,this.updateParticleData(t)),this.updateResult(t,a)):(t.updated=!1,t.result.alpha=0),e>=t.delay+t.duration&&(this.loop?(t.duration=this.getDuration(),t.delay=this.getDelay()):(s++,t.duration=0,t.result.alpha=0))})),this.delay=0,this.time+=t,s>=this.particles.length&&this.onComplete()}reset(){this.time=0,this.delay=0,this.particles.forEach((t=>{t.updated=!1,t.delay=this.getDelay(),t.duration=this.getDuration(),t.result&&(t.result.alpha=0,t.result.x=0,t.result.y=0)}))}onComplete(){this.cb&&this.cb()}set posStartX(t){this.posStart.x=t}set posStartY(t){this.posStart.y=t}set posEndX(t){this.posEnd.x=t}set posEndY(t){this.posEnd.y=t}setPosStart(t,e){this.posStart.x=t,this.posStart.y=e}setPosEnd(t,e){this.posEnd.x=t,this.posEnd.y=e}setData(t){this.correctedTintArr=null,this.config=t}getDuration(){return this.getValue("duration")}getDelay(){return this.delay+=this.getValue("delay"),this.time+this.delay}updateParticleData(e){const s=this.posStart.x+this.getValue("posStartOffsetX"),a=this.posStart.y+this.getValue("posStartOffsetY"),i=this.posEnd.x+this.getValue("posEndOffsetX"),r=this.posEnd.y+this.getValue("posEndOffsetY");e.posStart={x:s,y:a},e.posEnd={x:i,y:r},e.cp1=null,e.cp2=null;const o=this.getValue("posControlPoint1Mag"),h=this.getValue("posControlPoint2Mag");if(0!==o||0!==h){const l=i-s,n=r-a,c=Math.atan2(l,n),p=c+t(this.getValue("posControlPoint1Angle")),u=-(Math.PI-c)+t(this.getValue("posControlPoint2Angle")),d=Math.sqrt(l*l+n*n);e.cp1={x:s+Math.sin(p)*d*o,y:a+Math.cos(p)*d*o},e.cp2={x:i+Math.sin(u)*d*h,y:r+Math.cos(u)*d*h},e.curve?e.curve.length=0:e.curve=[]}else e.curve=void 0;e.alphaFrom=this.getValue("alphaFrom"),e.alphaTo=this.getValue("alphaTo"),e.alphaYoYo=this.getValue("alphaYoYo"),this.config.tint&&(this.config.tintInterpolate&&Array.isArray(this.config.tint)&&this.config.tint.length>1?(this.correctedTintArr||(this.correctedTintArr=n(this.config.tint,10)),e.tint=this.correctedTintArr):e.tint=parseInt(this.getValue("tint"))),e.scaleFrom=this.getValue("scaleFrom"),e.scaleTo=this.getValue("scaleTo"),e.scaleYoYo=this.getValue("scaleYoYo"),e.rotationSpeed=t(this.getValue("rotationSpeed"))}getValue(t){if(Array.isArray(this.config[t])){const e=this.config[t],s=e.length>1?Math.floor(Math.random()*e.length):0;if(Array.isArray(e[s])){const t=e[s][0],a=e[s][1];return Math.random()*(a-t)+t}return e[s]}return this.config[t]||0}updateResult(t,i){const r=i*(1-i)*2,o=t.result;if(o.alpha=t.alphaFrom+(t.alphaTo-t.alphaFrom)*(t.alphaYoYo?r:i),o.scaleX=o.scaleY=e(t.scaleYoYo?r:i,t.scaleFrom,t.scaleTo),t.curve){const e=Math.floor(i/this.curveSeg),r=e+1;void 0===t.curve[e]&&(t.curve[e]=0===e?t.posStart:new h),void 0===t.curve[r]&&(t.curve[r]=r===this.curveLen-1?t.posEnd:new h),0!==e&&s(e*this.curveSeg,t.posStart,t.cp1,t.cp2,t.posEnd,t.curve[e]),r!==this.curveLen-1&&s(r*this.curveSeg,t.posStart,t.cp1,t.cp2,t.posEnd,t.curve[r]),a(i%this.curveSeg/this.curveSeg,t.curve[e],t.curve[r],o)}else a(i,t.posStart,t.posEnd,o);if(0!==t.rotationSpeed?o.rotation+=t.rotationSpeed:o.rotation=0,t.tint)if(Array.isArray(t.tint)){const e=1/(t.tint.length-1);o.tint=t.tint[Math.floor(i/e)]}else o.tint=t.tint}kill(){this.particles.length=0,this.cb=null}}const n=(t,e)=>{const s=t.map((t=>i(parseInt(t)))),a=[],h=1/e,l=1/(s.length-1);for(let t=0;t<e+1;t++){const e=Math.min(h*t,1),i=Math.min(Math.floor(e/l),s.length-2),n=s[i],c=s[i+1];a.push(r(...n.map(((t,s)=>o(e,t,c[s])))))}return a};export{l as Particles};
//# sourceMappingURL=dizzy-particles.min.js.map
